## 初探SSR——NuxtJS使用心得

#### 首先附上官方Nuxt + Express标准模板[https://github.com/nuxt-community/express-template](https://github.com/nuxt-community/express-template)

#### 顾名思义，服务器端渲染 (server side render)即在服务器上把组件渲染成HTML字符串，浏览器端直接进行解析，进而达到首屏数据无需等待直接拥有内容。标准前后端分离模式下，通常采用客户端渲染。客户端渲染流程：
###### + 浏览器向Express(Node服务器)发送请求，请求页面URL
###### + Node服务返回静态文件中的首屏HTML文件，此时内容为空
###### + 浏览器向Express(Node服务器)发送请求，请求页面资源
###### + Node服务获取服务器上文件后，返回页面必要资源文件
###### + 浏览器向Express(Node服务器)发送后续AJAX请求
###### + Node服务响应AJAX请求

#### 服务端渲染流程：
###### + 浏览器向Express(Node服务器)发送请求，请求页面URL
###### + Node服务向后端服务器请求首屏数据后返回渲染好的首屏HTML文件
###### + 浏览器向Express(Node服务器)发送后续AJAX请求
###### + Node服务响应AJAX请求

#### 对比后可以很明显的发现，SSR对比客户端渲染，减少了客户端压力，在弱网环境下也可以很快的获取到渲染后的HTML文件，同时更利于SEO和爬虫引擎爬取数据。正所谓，有无之相生也，难易之相成也，长短之相刑也，高下之相盈也，音声之相和也。有优点的同时必然少不了对应的缺点，浏览器端减少的压力并不会凭空消失，将会转换为对应甚至更高的压力移交给服务器端，因此服务器压力巨大。并且SSR下只会执行到ComponentMount之前的生命周期钩子，引用第三方库不可用其他生命周期钩子，引用库选择产生很大的限制。额外的学习成本也是不可忽视的，因此技术选型时一定要考虑好自己的切实需求。假如是一个中后台系统或者仪表盘系统(各种平淡无奇巨坑无比祖传内部系统)，那就完全没有使用SSR的必要了，额外造成服务器的巨大开销忽略不计，改造浪费的时间人力也体现不出任何价值，如果是系统中部分营销页面，可以使用官方推荐的[预渲染（pre render）](https://github.com/chrisvfritz/prerender-spa-plugin)。